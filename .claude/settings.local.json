{
  "permissions": {
    "allow": [
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(gsutil cors set:*)",
      "Bash(gcloud projects:*)",
      "Bash(gcloud config set:*)",
      "Bash(gsutil cors get:*)",
      "Bash(wc:*)",
      "Bash(firebase deploy:*)",
      "Bash(npm install:*)",
      "Bash(npm uninstall:*)",
      "WebSearch",
      "WebFetch(domain:elevenlabs.io)",
      "WebFetch(domain:github.com)",
      "Bash(npm run build:*)",
      "Bash(npx tsc:*)",
      "Bash(xargs cat:*)",
      "Bash(ls:*)",
      "Bash(xargs:*)",
      "Bash(git rm:*)",
      "mcp__angular-cli__get_best_practices",
      "Bash(npm run build:backend:*)",
      "mcp__angular-cli__list_projects",
      "Bash(find:*)",
      "Bash(cat:*)",
      "Bash(node:*)",
      "Bash(firebase firestore:documents:get:*)",
      "Bash(firebase --help:*)",
      "Bash(curl:*)",
      "Bash(gcloud logging read:*)",
      "Bash(gcloud functions logs:*)",
      "Bash(gcloud functions describe:*)",
      "mcp__firebase__firestore_list_collections",
      "mcp__firebase__firestore_query_collection",
      "Bash(firebase firestore:get:*)",
      "Bash(/Users/mattcady/git/questmind/src/app/campaign/user-profile.service.ts << 'EOF'\nimport { Injectable } from '@angular/core';\nimport {\n  doc,\n  getDoc,\n  setDoc,\n  updateDoc,\n  type Firestore\n} from 'firebase/firestore';\nimport type { User } from 'firebase/auth';\nimport { UserProfile } from './campaign.models';\nimport { FirebaseService } from '../core/firebase.service';\n\n@Injectable\\({ providedIn: 'root' }\\)\nexport class UserProfileService {\n  private readonly db: Firestore | null;\n\n  constructor\\(private readonly firebase: FirebaseService\\) {\n    this.db = this.firebase.firestore;\n  }\n\n  async getProfile\\(userId: string\\): Promise<UserProfile | null> {\n    if \\(!this.db\\) {\n      return null;\n    }\n    const userRef = doc\\(this.db, 'users', userId\\);\n    const snapshot = await getDoc\\(userRef\\);\n    return snapshot.exists\\(\\) ? \\(snapshot.data\\(\\) as UserProfile\\) : null;\n  }\n\n  async ensureProfile\\(user: User\\): Promise<UserProfile> {\n    if \\(!this.db\\) {\n      throw new Error\\('Firestore is not configured. Cannot ensure user profile.'\\);\n    }\n\n    const userRef = doc\\(this.db, 'users', user.uid\\);\n    const snapshot = await getDoc\\(userRef\\);\n    if \\(snapshot.exists\\(\\)\\) {\n      const existing = snapshot.data\\(\\) as UserProfile;\n      const normalizedEmail = \\(user.email || ''\\).toLowerCase\\(\\);\n      const updates: Partial<UserProfile> = {};\n      if \\(normalizedEmail && existing.email !== normalizedEmail\\) {\n        updates.email = normalizedEmail;\n      }\n      if \\(!Array.isArray\\(existing.campaigns\\)\\) {\n        updates.campaigns = [];\n      }\n      if \\(Object.keys\\(updates\\).length > 0\\) {\n        await updateDoc\\(userRef, {\n          ...updates,\n          updatedAt: new Date\\(\\)\n        }\\);\n        return { ...existing, ...updates };\n      }\n      return existing;\n    }\n\n    const now = new Date\\(\\);\n    const email = \\(user.email || ''\\).toLowerCase\\(\\);\n    const profile: UserProfile = {\n      uid: user.uid,\n      email,\n      displayName: user.displayName || undefined,\n      photoURL: user.photoURL || undefined,\n      campaigns: [],\n      createdAt: now,\n      updatedAt: now\n    };\n\n    await setDoc\\(userRef, profile, { merge: true }\\);\n    return profile;\n  }\n\n  async addCampaign\\(userId: string, campaignId: string\\): Promise<void> {\n    if \\(!this.db\\) return;\n    const userRef = doc\\(this.db, 'users', userId\\);\n    const snapshot = await getDoc\\(userRef\\);\n    if \\(!snapshot.exists\\(\\)\\) {\n      await setDoc\\(userRef, {\n        uid: userId,\n        campaigns: [campaignId],\n        updatedAt: new Date\\(\\)\n      }, { merge: true }\\);\n      return;\n    }\n    const data = snapshot.data\\(\\) as UserProfile;\n    const campaigns = data.campaigns ?? [];\n    if \\(campaigns.includes\\(campaignId\\)\\) {\n      return;\n    }\n    await updateDoc\\(userRef, {\n      campaigns: [...campaigns, campaignId],\n      updatedAt: new Date\\(\\)\n    }\\);\n  }\n\n  async removeCampaign\\(userId: string, campaignId: string\\): Promise<void> {\n    if \\(!this.db\\) return;\n    const userRef = doc\\(this.db, 'users', userId\\);\n    const snapshot = await getDoc\\(userRef\\);\n    if \\(!snapshot.exists\\(\\)\\) return;\n    const data = snapshot.data\\(\\) as UserProfile;\n    const campaigns = \\(data.campaigns ?? []\\).filter\\(id => id !== campaignId\\);\n    await updateDoc\\(userRef, {\n      campaigns,\n      updatedAt: new Date\\(\\)\n    }\\);\n  }\n\n  async setDefaultCampaign\\(userId: string, campaignId: string | null\\): Promise<void> {\n    if \\(!this.db\\) return;\n    const userRef = doc\\(this.db, 'users', userId\\);\n    await updateDoc\\(userRef, {\n      defaultCampaignId: campaignId,\n      updatedAt: new Date\\(\\)\n    }\\);\n  }\n}\nEOF)",
      "Bash(/Users/mattcady/git/questmind/src/app/audio/services/audio-storage.service.ts << 'EOF'\nimport { Injectable } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport {\n  getDownloadURL,\n  ref,\n  uploadBytesResumable,\n  type FirebaseStorage\n} from 'firebase/storage';\n\nimport { StorageMetadata, UploadProgress } from './audio-session.models';\nimport { FirebaseService } from '../../core/firebase.service';\n\nconst MAX_FILE_BYTES = 500 * 1024 * 1024;\nconst SUPPORTED_TYPES = [\n  'audio/mpeg',\n  'audio/wav',\n  'audio/x-wav',\n  'audio/mp4',\n  'audio/x-m4a',\n  'audio/ogg'\n];\n\n@Injectable\\({\n  providedIn: 'root'\n}\\)\nexport class AudioStorageService {\n  private readonly storage: FirebaseStorage | null;\n\n  constructor\\(private readonly firebase: FirebaseService\\) {\n    this.storage = this.firebase.storage;\n  }\n\n  validateFile\\(file: File\\): string | null {\n    if \\(!SUPPORTED_TYPES.includes\\(file.type\\)\\) {\n      return 'Unsupported file type. Please use MP3, WAV, M4A, or OGG.';\n    }\n    if \\(file.size > MAX_FILE_BYTES\\) {\n      return 'File is too large. Maximum size is 500MB.';\n    }\n    return null;\n  }\n\n  uploadAudioFile\\(file: File, campaignId: string, sessionId: string\\): Observable<UploadProgress> {\n    if \\(!this.storage\\) {\n      return throwError\\(\\(\\) => new Error\\('Firebase Storage is not configured.'\\)\\);\n    }\n    const storagePath = this.getStoragePath\\(campaignId, sessionId, file.name\\);\n    const storageRef = ref\\(this.storage, storagePath\\);\n\n    return new Observable<UploadProgress>\\(observer => {\n      const uploadTask = uploadBytesResumable\\(storageRef, file, { contentType: file.type }\\);\n\n      const unsubscribe = uploadTask.on\\(\n        'state_changed',\n        snapshot => {\n          const progress = Math.round\\(\\(snapshot.bytesTransferred / snapshot.totalBytes\\) * 100\\);\n          observer.next\\({\n            sessionId,\n            progress,\n            bytesTransferred: snapshot.bytesTransferred,\n            totalBytes: snapshot.totalBytes,\n            status: snapshot.bytesTransferred >= snapshot.totalBytes ? 'completed' : 'uploading'\n          }\\);\n        },\n        error => {\n          observer.error\\(error\\);\n        },\n        \\(\\) => {\n          observer.complete\\(\\);\n        }\n      \\);\n\n      return \\(\\) => unsubscribe\\(\\);\n    }\\);\n  }\n\n  async buildStorageMetadata\\(file: File, campaignId: string, sessionId: string\\): Promise<StorageMetadata> {\n    if \\(!this.storage\\) {\n      throw new Error\\('Firebase Storage is not configured.'\\);\n    }\n\n    const storagePath = this.getStoragePath\\(campaignId, sessionId, file.name\\);\n    const storageRef = ref\\(this.storage, storagePath\\);\n    const downloadUrl = await getDownloadURL\\(storageRef\\);\n\n    return {\n      storagePath,\n      downloadUrl,\n      fileSize: file.size,\n      contentType: file.type,\n      uploadedAt: new Date\\(\\).toISOString\\(\\)\n    };\n  }\n\n  getStoragePath\\(campaignId: string, sessionId: string, fileName: string\\): string {\n    return `campaigns/${campaignId}/audio/${sessionId}/${fileName}`;\n  }\n\n  async fetchAudioFromUrl\\(url: string\\): Promise<Blob> {\n    const response = await fetch\\(url\\);\n    if \\(!response.ok\\) {\n      throw new Error\\(`Failed to fetch audio from URL: ${response.status} ${response.statusText}`\\);\n    }\n    return await response.blob\\(\\);\n  }\n}\nEOF)"
    ]
  },
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": [
    "firebase"
  ],
  "outputStyle": "default"
}
