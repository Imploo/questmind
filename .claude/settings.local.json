{
  "permissions": {
    "allow": [
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(gsutil cors set:*)",
      "Bash(gcloud projects:*)",
      "Bash(gcloud config set:*)",
      "Bash(gsutil cors get:*)",
      "Bash(wc:*)",
      "Bash(firebase deploy:*)",
      "Bash(npm install:*)",
      "Bash(npm uninstall:*)",
      "WebSearch",
      "WebFetch(domain:elevenlabs.io)",
      "WebFetch(domain:github.com)",
      "Bash(npm run build:*)",
      "Bash(npx tsc:*)",
      "Bash(xargs cat:*)",
      "Bash(ls:*)",
      "Bash(xargs:*)",
      "Bash(git rm:*)",
      "mcp__angular-cli__get_best_practices",
      "Bash(npm run build:backend:*)",
      "mcp__angular-cli__list_projects",
      "Bash(find:*)",
      "Bash(cat:*)",
      "Bash(node:*)",
      "Bash(firebase firestore:documents:get:*)",
      "Bash(firebase --help:*)",
      "Bash(curl:*)",
      "Bash(gcloud logging read:*)",
      "Bash(gcloud functions logs:*)",
      "Bash(gcloud functions describe:*)",
      "mcp__firebase__firestore_list_collections",
      "mcp__firebase__firestore_query_collection",
      "Bash(firebase firestore:get:*)",
      "Bash(/Users/mattcady/git/questmind/src/app/campaign/user-profile.service.ts << 'EOF'\nimport { Injectable } from '@angular/core';\nimport {\n  doc,\n  getDoc,\n  setDoc,\n  updateDoc,\n  type Firestore\n} from 'firebase/firestore';\nimport type { User } from 'firebase/auth';\nimport { UserProfile } from './campaign.models';\nimport { FirebaseService } from '../core/firebase.service';\n\n@Injectable\\({ providedIn: 'root' }\\)\nexport class UserProfileService {\n  private readonly db: Firestore | null;\n\n  constructor\\(private readonly firebase: FirebaseService\\) {\n    this.db = this.firebase.firestore;\n  }\n\n  async getProfile\\(userId: string\\): Promise<UserProfile | null> {\n    if \\(!this.db\\) {\n      return null;\n    }\n    const userRef = doc\\(this.db, 'users', userId\\);\n    const snapshot = await getDoc\\(userRef\\);\n    return snapshot.exists\\(\\) ? \\(snapshot.data\\(\\) as UserProfile\\) : null;\n  }\n\n  async ensureProfile\\(user: User\\): Promise<UserProfile> {\n    if \\(!this.db\\) {\n      throw new Error\\('Firestore is not configured. Cannot ensure user profile.'\\);\n    }\n\n    const userRef = doc\\(this.db, 'users', user.uid\\);\n    const snapshot = await getDoc\\(userRef\\);\n    if \\(snapshot.exists\\(\\)\\) {\n      const existing = snapshot.data\\(\\) as UserProfile;\n      const normalizedEmail = \\(user.email || ''\\).toLowerCase\\(\\);\n      const updates: Partial<UserProfile> = {};\n      if \\(normalizedEmail && existing.email !== normalizedEmail\\) {\n        updates.email = normalizedEmail;\n      }\n      if \\(!Array.isArray\\(existing.campaigns\\)\\) {\n        updates.campaigns = [];\n      }\n      if \\(Object.keys\\(updates\\).length > 0\\) {\n        await updateDoc\\(userRef, {\n          ...updates,\n          updatedAt: new Date\\(\\)\n        }\\);\n        return { ...existing, ...updates };\n      }\n      return existing;\n    }\n\n    const now = new Date\\(\\);\n    const email = \\(user.email || ''\\).toLowerCase\\(\\);\n    const profile: UserProfile = {\n      uid: user.uid,\n      email,\n      displayName: user.displayName || undefined,\n      photoURL: user.photoURL || undefined,\n      campaigns: [],\n      createdAt: now,\n      updatedAt: now\n    };\n\n    await setDoc\\(userRef, profile, { merge: true }\\);\n    return profile;\n  }\n\n  async addCampaign\\(userId: string, campaignId: string\\): Promise<void> {\n    if \\(!this.db\\) return;\n    const userRef = doc\\(this.db, 'users', userId\\);\n    const snapshot = await getDoc\\(userRef\\);\n    if \\(!snapshot.exists\\(\\)\\) {\n      await setDoc\\(userRef, {\n        uid: userId,\n        campaigns: [campaignId],\n        updatedAt: new Date\\(\\)\n      }, { merge: true }\\);\n      return;\n    }\n    const data = snapshot.data\\(\\) as UserProfile;\n    const campaigns = data.campaigns ?? [];\n    if \\(campaigns.includes\\(campaignId\\)\\) {\n      return;\n    }\n    await updateDoc\\(userRef, {\n      campaigns: [...campaigns, campaignId],\n      updatedAt: new Date\\(\\)\n    }\\);\n  }\n\n  async removeCampaign\\(userId: string, campaignId: string\\): Promise<void> {\n    if \\(!this.db\\) return;\n    const userRef = doc\\(this.db, 'users', userId\\);\n    const snapshot = await getDoc\\(userRef\\);\n    if \\(!snapshot.exists\\(\\)\\) return;\n    const data = snapshot.data\\(\\) as UserProfile;\n    const campaigns = \\(data.campaigns ?? []\\).filter\\(id => id !== campaignId\\);\n    await updateDoc\\(userRef, {\n      campaigns,\n      updatedAt: new Date\\(\\)\n    }\\);\n  }\n\n  async setDefaultCampaign\\(userId: string, campaignId: string | null\\): Promise<void> {\n    if \\(!this.db\\) return;\n    const userRef = doc\\(this.db, 'users', userId\\);\n    await updateDoc\\(userRef, {\n      defaultCampaignId: campaignId,\n      updatedAt: new Date\\(\\)\n    }\\);\n  }\n}\nEOF)",
      "Bash(/Users/mattcady/git/questmind/src/app/audio/services/audio-storage.service.ts << 'EOF'\nimport { Injectable } from '@angular/core';\nimport { Observable, throwError } from 'rxjs';\nimport {\n  getDownloadURL,\n  ref,\n  uploadBytesResumable,\n  type FirebaseStorage\n} from 'firebase/storage';\n\nimport { StorageMetadata, UploadProgress } from './audio-session.models';\nimport { FirebaseService } from '../../core/firebase.service';\n\nconst MAX_FILE_BYTES = 500 * 1024 * 1024;\nconst SUPPORTED_TYPES = [\n  'audio/mpeg',\n  'audio/wav',\n  'audio/x-wav',\n  'audio/mp4',\n  'audio/x-m4a',\n  'audio/ogg'\n];\n\n@Injectable\\({\n  providedIn: 'root'\n}\\)\nexport class AudioStorageService {\n  private readonly storage: FirebaseStorage | null;\n\n  constructor\\(private readonly firebase: FirebaseService\\) {\n    this.storage = this.firebase.storage;\n  }\n\n  validateFile\\(file: File\\): string | null {\n    if \\(!SUPPORTED_TYPES.includes\\(file.type\\)\\) {\n      return 'Unsupported file type. Please use MP3, WAV, M4A, or OGG.';\n    }\n    if \\(file.size > MAX_FILE_BYTES\\) {\n      return 'File is too large. Maximum size is 500MB.';\n    }\n    return null;\n  }\n\n  uploadAudioFile\\(file: File, campaignId: string, sessionId: string\\): Observable<UploadProgress> {\n    if \\(!this.storage\\) {\n      return throwError\\(\\(\\) => new Error\\('Firebase Storage is not configured.'\\)\\);\n    }\n    const storagePath = this.getStoragePath\\(campaignId, sessionId, file.name\\);\n    const storageRef = ref\\(this.storage, storagePath\\);\n\n    return new Observable<UploadProgress>\\(observer => {\n      const uploadTask = uploadBytesResumable\\(storageRef, file, { contentType: file.type }\\);\n\n      const unsubscribe = uploadTask.on\\(\n        'state_changed',\n        snapshot => {\n          const progress = Math.round\\(\\(snapshot.bytesTransferred / snapshot.totalBytes\\) * 100\\);\n          observer.next\\({\n            sessionId,\n            progress,\n            bytesTransferred: snapshot.bytesTransferred,\n            totalBytes: snapshot.totalBytes,\n            status: snapshot.bytesTransferred >= snapshot.totalBytes ? 'completed' : 'uploading'\n          }\\);\n        },\n        error => {\n          observer.error\\(error\\);\n        },\n        \\(\\) => {\n          observer.complete\\(\\);\n        }\n      \\);\n\n      return \\(\\) => unsubscribe\\(\\);\n    }\\);\n  }\n\n  async buildStorageMetadata\\(file: File, campaignId: string, sessionId: string\\): Promise<StorageMetadata> {\n    if \\(!this.storage\\) {\n      throw new Error\\('Firebase Storage is not configured.'\\);\n    }\n\n    const storagePath = this.getStoragePath\\(campaignId, sessionId, file.name\\);\n    const storageRef = ref\\(this.storage, storagePath\\);\n    const downloadUrl = await getDownloadURL\\(storageRef\\);\n\n    return {\n      storagePath,\n      downloadUrl,\n      fileSize: file.size,\n      contentType: file.type,\n      uploadedAt: new Date\\(\\).toISOString\\(\\)\n    };\n  }\n\n  getStoragePath\\(campaignId: string, sessionId: string, fileName: string\\): string {\n    return `campaigns/${campaignId}/audio/${sessionId}/${fileName}`;\n  }\n\n  async fetchAudioFromUrl\\(url: string\\): Promise<Blob> {\n    const response = await fetch\\(url\\);\n    if \\(!response.ok\\) {\n      throw new Error\\(`Failed to fetch audio from URL: ${response.status} ${response.statusText}`\\);\n    }\n    return await response.blob\\(\\);\n  }\n}\nEOF)",
      "Bash(git mv:*)",
      "Bash(/tmp/transcribe-audio-fast.ts << 'EOF'\nimport * as logger from './utils/logger';\nimport { GoogleGenAI } from '@google/genai';\nimport { CallableRequest, HttpsError, onCall } from 'firebase-functions/v2/https';\nimport { FieldValue, getFirestore } from 'firebase-admin/firestore';\nimport { storage } from 'firebase-admin';\nimport { AIFeatureConfig, AISettings, TranscriptionSegment } from './types/audio-session.types';\nimport { ProgressTrackerService } from './services/progress-tracker.service';\nimport { WorkerQueueService } from './services/worker-queue.service';\nimport { buildTranscriptionPrompt } from './audio/transcription-prompt';\nimport { fetchKankaContextForTranscription } from './services/kanka.service';\n\nexport interface TranscribeAudioFastRequest {\n  campaignId: string;\n  sessionId: string;\n  storageUrl: string;\n  audioFileName: string;\n  audioFileSize?: number;\n  userCorrections?: string;\n}\n\ninterface TranscriptionResponsePayload {\n  segments?: TranscriptionSegment[];\n  error?: string;\n  message?: string;\n}\n\n/**\n * Fast transcription using direct Gemini API call\n *\n * This function uses a fire-and-forget pattern:\n * 1. Validates input and updates progress\n * 2. Returns immediately to frontend\n * 3. Processes transcription asynchronously in background\n * 4. Updates Firestore with results\n * 5. Triggers story generation when complete\n */\nexport const transcribeAudioFast = onCall\\(\n  {\n    timeoutSeconds: 540, // 9 minutes - allow time for processing\n    memory: '1GiB',\n    secrets: ['GOOGLE_AI_API_KEY', 'KANKA_API_TOKEN'],\n  },\n  async \\(\n    request: CallableRequest<TranscribeAudioFastRequest>\n  \\): Promise<{ success: boolean; message: string }> => {\n    const {\n      campaignId,\n      sessionId,\n      storageUrl,\n      audioFileName,\n      userCorrections,\n    } = request.data;\n\n    // Validate required fields\n    if \\(!campaignId || !sessionId || !storageUrl || !audioFileName\\) {\n      throw new HttpsError\\(\n        'invalid-argument',\n        'Missing required fields: campaignId, sessionId, storageUrl, audioFileName'\n      \\);\n    }\n\n    if \\(!storageUrl.startsWith\\('gs://'\\)\\) {\n      throw new HttpsError\\(\n        'invalid-argument',\n        'storageUrl must be a gs:// URL'\n      \\);\n    }\n\n    const googleAiKey = process.env.GOOGLE_AI_API_KEY;\n    if \\(!googleAiKey\\) {\n      throw new HttpsError\\(\n        'failed-precondition',\n        'Google AI API key not configured'\n      \\);\n    }\n\n    const db = getFirestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n\n    // Validate session exists\n    const sessionSnap = await sessionRef.get\\(\\);\n    if \\(!sessionSnap.exists\\) {\n      throw new HttpsError\\(\n        'not-found',\n        `Audio session ${sessionId} not found`\n      \\);\n    }\n\n    // Update progress to transcribing \\(fire-and-forget starts here\\)\n    await ProgressTrackerService.updateProgress\\(\n      campaignId,\n      sessionId,\n      'transcribing',\n      40,\n      'Fast transcription started...'\n    \\);\n\n    // Fetch Kanka enabled setting from campaign settings\n    const kankaEnabled = await getCampaignKankaEnabled\\(campaignId\\);\n\n    // Store fast transcription metadata\n    await sessionRef.update\\({\n      transcriptionFast: {\n        mode: 'fast',\n        enableKankaContext: kankaEnabled,\n        userCorrections,\n        storageUrl,\n        audioFileName,\n        submittedAt: FieldValue.serverTimestamp\\(\\),\n        status: 'processing',\n      },\n    }\\);\n\n    // Start async processing \\(don't await - fire and forget\\)\n    processTranscriptionAsync\\(\n      campaignId,\n      sessionId,\n      storageUrl,\n      audioFileName,\n      kankaEnabled,\n      userCorrections\n    \\).catch\\(\\(error\\) => {\n      console.error\\('[transcribeAudioFast] Async processing failed:', error\\);\n      // Error will be written to Firestore by processTranscriptionAsync\n    }\\);\n\n    // Return immediately - frontend will monitor Firestore for updates\n    return {\n      success: true,\n      message: 'Fast transcription started',\n    };\n  }\n\\);\n\n/**\n * Helper function to fetch Kanka enabled setting from campaign settings\n */\nasync function getCampaignKankaEnabled\\(campaignId: string\\): Promise<boolean> {\n  const db = getFirestore\\(\\);\n  const campaignRef = db.collection\\('campaigns'\\).doc\\(campaignId\\);\n  const campaignSnap = await campaignRef.get\\(\\);\n\n  if \\(!campaignSnap.exists\\) {\n    logger.warn\\(`Campaign ${campaignId} not found, defaulting kankaEnabled to false`\\);\n    return false;\n  }\n\n  const campaignData = campaignSnap.data\\(\\);\n  return campaignData?.settings?.kankaEnabled ?? false;\n}\n\n/**\n * Process transcription asynchronously in the background\n */\nasync function processTranscriptionAsync\\(\n  campaignId: string,\n  sessionId: string,\n  storageUrl: string,\n  audioFileName: string,\n  enableKankaContext: boolean,\n  userCorrections?: string\n\\): Promise<void> {\n  const db = getFirestore\\(\\);\n  const sessionRef = db\n    .collection\\('campaigns'\\)\n    .doc\\(campaignId\\)\n    .collection\\('audioSessions'\\)\n    .doc\\(sessionId\\);\n\n  const startTime = Date.now\\(\\);\n\n  try {\n    logger.debug\\(`[Fast Transcription] Starting for session ${sessionId}`\\);\n\n    // 1. Get AI settings\n    const settingsSnap = await db.doc\\('settings/ai'\\).get\\(\\);\n    const aiSettings = settingsSnap.data\\(\\) as AISettings | undefined;\n\n    if \\(!aiSettings\\) {\n      throw new Error\\('AI settings not configured in database'\\);\n    }\n\n    const transcriptionConfig: AIFeatureConfig = aiSettings.features\n      ?.transcription ?? {\n      model: aiSettings.defaultModel,\n      temperature: 0.1,\n      topP: 1,\n      topK: 40,\n      maxOutputTokens: 128000,\n    };\n\n    const model = resolveModel\\(aiSettings, transcriptionConfig.model\\);\n    const mimeType = resolveMimeType\\(audioFileName\\);\n\n    logger.debug\\(`[Fast Transcription] Using model: ${model}`\\);\n\n    // 2. Fetch Kanka context if enabled\n    const kankaContext = await fetchKankaContextForTranscription\\(\n      campaignId,\n      sessionId,\n      enableKankaContext\n    \\);\n\n    // 3. Generate signed URL for Gemini API access\n    const bucket = storage\\(\\).bucket\\(\\);\n    const filePath = storageUrl.replace\\(`gs://${bucket.name}/`, ''\\);\n    const file = bucket.file\\(filePath\\);\n\n    logger.debug\\(`[Fast Transcription] Generating signed URL for: ${filePath}`\\);\n\n    const [signedUrl] = await file.getSignedUrl\\({\n      action: 'read',\n      expires: Date.now\\(\\) + 60 * 60 * 1000, // 1 hour \\(enough for fast processing\\)\n    }\\);\n\n    // 4. Call Gemini API directly \\(not batch\\)\n    const googleAi = new GoogleGenAI\\({ apiKey: process.env.GOOGLE_AI_API_KEY! }\\);\n\n    const prompt = buildTranscriptionPrompt\\(kankaContext\\);\n\n    logger.debug\\(`[Fast Transcription] Calling Gemini API with request:`, {\n      model,\n      config: {\n        temperature: transcriptionConfig.temperature,\n        topK: transcriptionConfig.topK,\n        topP: transcriptionConfig.topP,\n        maxOutputTokens: transcriptionConfig.maxOutputTokens,\n      },\n      prompt: prompt,\n      hasKankaContext: !!kankaContext,\n      mimeType,\n    }\\);\n\n    const result = await googleAi.models.generateContent\\({\n      model: model,\n      contents: [\n        {\n          role: 'user',\n          parts: [\n            { text: prompt },\n            {\n              fileData: {\n                mimeType: mimeType,\n                fileUri: signedUrl,\n              },\n            },\n          ],\n        },\n      ],\n      config: {\n        temperature: transcriptionConfig.temperature,\n        topK: transcriptionConfig.topK,\n        topP: transcriptionConfig.topP,\n        maxOutputTokens: transcriptionConfig.maxOutputTokens,\n      },\n    }\\);\n\n    if \\(!result.text\\) {\n      throw new Error\\('No response text from Gemini API'\\);\n    }\n\n    const text = result.text;\n\n    logger.debug\\(`[Fast Transcription] Received response, parsing...`\\);\n\n    // 5. Parse JSON response\n    const transcriptionPayload = parseTranscriptionPayload\\(text\\);\n\n    if \\(transcriptionPayload.error\\) {\n      throw new Error\\(\n        transcriptionPayload.message || transcriptionPayload.error\n      \\);\n    }\n\n    if \\(!transcriptionPayload.segments || transcriptionPayload.segments.length === 0\\) {\n      throw new Error\\('No transcription segments found in audio'\\);\n    }\n\n    const processingTimeMs = Date.now\\(\\) - startTime;\n\n    logger.debug\\(\n      `[Fast Transcription] Found ${transcriptionPayload.segments.length} segments in ${processingTimeMs}ms`\n    \\);\n\n    // 6. Format transcription with timestamps\n    const timestamps = transcriptionPayload.segments.map\\(segment => \\({\n      time: Math.max\\(0, Math.round\\(segment.timeSeconds\\)\\),\n      text: segment.speaker\n        ? `${segment.speaker}: ${segment.text}`\n        : segment.text,\n    }\\)\\);\n\n    const transcriptionText = timestamps\n      .map\\(entry => `[${formatTimestamp\\(entry.time\\)}] ${entry.text}`\\)\n      .join\\('\\\\n\\\\n'\\);\n\n    // 7. Update Firestore with transcription\n    await sessionRef.update\\({\n      'transcription.rawTranscript': transcriptionText,\n      'transcription.timestamps': timestamps,\n      'transcription.segments': transcriptionPayload.segments,\n      transcriptionCompletedAt: FieldValue.serverTimestamp\\(\\),\n      'transcriptionFast.status': 'completed',\n      'transcriptionFast.processingTimeMs': processingTimeMs,\n      'transcriptionFast.modelUsed': model,\n      'transcriptionFast.completedAt': FieldValue.serverTimestamp\\(\\),\n      'modelsUsed.transcription': model,\n    }\\);\n\n    await ProgressTrackerService.updateProgress\\(\n      campaignId,\n      sessionId,\n      'transcribing',\n      80,\n      'Transcription complete, preparing story generation...'\n    \\);\n\n    logger.debug\\(`[Fast Transcription] Triggering story generation worker...`\\);\n\n    // 8. Trigger story generation worker\n    const { storyGenerationWorkerHandler } = await import\\(\n      './workers/story-generation-worker'\n    \\);\n    await WorkerQueueService.triggerWorker\\(storyGenerationWorkerHandler, {\n      campaignId,\n      sessionId,\n      transcriptionText,\n      enableKankaContext,\n      userCorrections,\n    }\\);\n\n    logger.debug\\(`[Fast Transcription] Complete for session ${sessionId}`\\);\n  } catch \\(error: any\\) {\n    console.error\\('[Fast Transcription] Processing error:', error\\);\n\n    const errorMessage = error instanceof Error ? error.message : String\\(error\\);\n\n    // Update session with failure\n    await ProgressTrackerService.markFailed\\(\n      campaignId,\n      sessionId,\n      'transcribing',\n      errorMessage\n    \\);\n\n    await sessionRef.update\\({\n      'transcriptionFast.status': 'failed',\n      'transcriptionFast.error': errorMessage,\n      'transcriptionFast.failedAt': FieldValue.serverTimestamp\\(\\),\n    }\\);\n  }\n}\n\nfunction resolveModel\\(settings: AISettings, requestedModel?: string\\): string {\n  const availableModels = settings.availableModels ?? [];\n  const fallback = settings.defaultModel || 'gemini-2.0-flash-exp';\n  if \\(requestedModel && availableModels.length > 0\\) {\n    return availableModels.includes\\(requestedModel\\) ? requestedModel : fallback;\n  }\n  return requestedModel || fallback;\n}\n\nfunction resolveMimeType\\(audioFileName: string\\): string {\n  const extension = audioFileName.split\\('.'\\).pop\\(\\)?.toLowerCase\\(\\);\n  switch \\(extension\\) {\n    case 'wav':\n      return 'audio/wav';\n    case 'mp3':\n      return 'audio/mpeg';\n    case 'm4a':\n      return 'audio/mp4';\n    case 'webm':\n      return 'audio/webm';\n    case 'ogg':\n      return 'audio/ogg';\n    case 'flac':\n      return 'audio/flac';\n    default:\n      return 'audio/mpeg';\n  }\n}\n\nfunction parseTranscriptionPayload\\(rawText: string\\): TranscriptionResponsePayload {\n  try {\n    // Strip markdown code blocks if present \\(```json ... ``` or ``` ... ```\\)\n    let cleanedText = rawText.trim\\(\\);\n\n    // Remove ```json or ``` at the start\n    if \\(cleanedText.startsWith\\('```json'\\)\\) {\n      cleanedText = cleanedText.slice\\(7\\); // Remove ```json\n    } else if \\(cleanedText.startsWith\\('```'\\)\\) {\n      cleanedText = cleanedText.slice\\(3\\); // Remove ```\n    }\n\n    // Remove ``` at the end\n    if \\(cleanedText.endsWith\\('```'\\)\\) {\n      cleanedText = cleanedText.slice\\(0, -3\\);\n    }\n\n    cleanedText = cleanedText.trim\\(\\);\n\n    const parsed = JSON.parse\\(cleanedText\\);\n\n    // If parsed is an array, wrap it in the expected format\n    if \\(Array.isArray\\(parsed\\)\\) {\n      return { segments: parsed as TranscriptionSegment[] };\n    }\n\n    // If parsed is an object with segments, return it\n    if \\(parsed && typeof parsed === 'object'\\) {\n      return parsed as TranscriptionResponsePayload;\n    }\n  } catch \\(error\\) {\n    logger.error\\('[parseTranscriptionPayload] JSON parse error:', error\\);\n    logger.error\\(\n      '[parseTranscriptionPayload] Raw text \\(first 200 chars\\):',\n      rawText.substring\\(0, 200\\)\n    \\);\n    return {\n      error: 'INVALID_JSON',\n      message: `Transcription response was not valid JSON: ${\n        error instanceof Error ? error.message : 'unknown error'\n      }`,\n    };\n  }\n\n  return {\n    error: 'INVALID_RESPONSE',\n    message: 'Transcription response could not be parsed',\n  };\n}\n\nfunction formatTimestamp\\(seconds: number\\): string {\n  const hours = Math.floor\\(seconds / 3600\\);\n  const minutes = Math.floor\\(\\(seconds % 3600\\) / 60\\);\n  const secs = Math.floor\\(seconds % 60\\);\n\n  if \\(hours > 0\\) {\n    return `${hours}:${minutes.toString\\(\\).padStart\\(2, '0'\\)}:${secs\n      .toString\\(\\)\n      .padStart\\(2, '0'\\)}`;\n  }\n\n  return `${minutes}:${secs.toString\\(\\).padStart\\(2, '0'\\)}`;\n}\nEOF)",
      "Bash(/tmp/check-batch-status.ts << 'EOF'\n#!/usr/bin/env node\n/**\n * Utility script to check the status of a Gemini batch job\n * Usage: tsx check-batch-status.ts <batchJobName>\n * Example: tsx check-batch-status.ts batches/wgbfhapzfm6mbcel50u2ac2592r3ypv2jlna\n */\n\nimport {GoogleGenAI} from '@google/genai';\nimport * as dotenv from 'dotenv';\nimport * as logger from './logger';\n\n// Load environment variables from .env file\ndotenv.config\\(\\);\n\nconst GOOGLE_AI_API_KEY = process.env.GOOGLE_AI_API_KEY;\n\nif \\(!GOOGLE_AI_API_KEY\\) {\n  console.error\\('Error: GOOGLE_AI_API_KEY environment variable not set'\\);\n  console.error\\('Please set it in your .env file or environment'\\);\n  process.exit\\(1\\);\n}\n\nconst batchJobName = process.argv[2];\n\nif \\(!batchJobName\\) {\n  console.error\\('Error: Please provide a batch job name as argument'\\);\n  console.error\\(\n    'Usage: tsx check-batch-status.ts batches/wgbfhapzfm6mbcel50u2ac2592r3ypv2jlna'\n  \\);\n  process.exit\\(1\\);\n}\n\nasync function checkBatchStatus\\(jobName: string\\): Promise<void> {\n  const ai = new GoogleGenAI\\({apiKey: GOOGLE_AI_API_KEY}\\);\n\n  try {\n    logger.info\\(`\\\\nFetching status for batch job: ${jobName}\\\\n`\\);\n\n    const batchJob = await ai.batches.get\\({name: jobName}\\);\n\n    logger.info\\('=== Batch Job Status ===\\\\n'\\);\n    logger.info\\(JSON.stringify\\(batchJob, null, 2\\)\\);\n\n    // Extract state if available\n    if \\(typeof batchJob === 'object' && batchJob !== null\\) {\n      const state = \\(batchJob as {state?: unknown}\\).state;\n      logger.info\\(`\\\\n=== Summary ===`\\);\n      logger.info\\(`State: ${state}`\\);\n\n      // Check for response data\n      const job = batchJob as {\n        dest?: {inlinedResponses?: unknown[]};\n        response?: {inlinedResponses?: unknown[]};\n      };\n\n      if \\(job.dest?.inlinedResponses || job.response?.inlinedResponses\\) {\n        logger.info\\('Response data: Available âœ“'\\);\n      } else {\n        logger.info\\('Response data: Not yet available'\\);\n      }\n    }\n  } catch \\(error\\) {\n    console.error\\('Error fetching batch job status:', error\\);\n    if \\(error instanceof Error\\) {\n      console.error\\('Message:', error.message\\);\n      console.error\\('Stack:', error.stack\\);\n    }\n    process.exit\\(1\\);\n  }\n}\n\ncheckBatchStatus\\(batchJobName\\);\nEOF)",
      "Bash(/tmp/generate-podcast-audio.ts << 'EOF'\nimport * as logger from './utils/logger';\nimport { onCall, HttpsError, CallableRequest } from 'firebase-functions/v2/https';\nimport { FieldValue, getFirestore } from 'firebase-admin/firestore';\nimport { getStorage } from 'firebase-admin/storage';\nimport { ElevenLabsClient } from '@elevenlabs/elevenlabs-js';\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport * as path from 'path';\nimport { Readable } from 'stream';\nimport { randomUUID } from 'crypto';\nimport { GoogleGenAI } from '@google/genai';\nimport { SHARED_CORS } from './index';\nimport { PODCAST_SCRIPT_GENERATOR_PROMPT } from './prompts/podcast-script-generator.prompt';\nimport { AISettings } from './types/audio-session.types';\nimport { ensureAuthForTesting } from './utils/emulator-helpers';\nimport { ProgressTrackerService } from './services/progress-tracker.service';\n\nconst DEFAULT_HOST_VOICES: Record<'host1' | 'host2', string> = {\n  host1: process.env.ELEVENLABS_HOST1_VOICE ?? '',\n  host2: process.env.ELEVENLABS_HOST2_VOICE ?? ''\n};\n\n/**\n * @deprecated Use ProgressTrackerService instead \\(Ticket #43\\)\n * Helper to update podcast-specific progress in Firestore\n * Still needed for updating individual podcast records, but unified session progress\n * should be tracked via ProgressTrackerService\n */\nasync function updatePodcastProgress\\(\n  sessionRef: FirebaseFirestore.DocumentReference,\n  existingPodcasts: any[],\n  version: number,\n  status: string,\n  progress: number,\n  message: string,\n  additionalData: any = {}\n\\) {\n  const updatedPodcast = {\n    version,\n    status,\n    progress,\n    progressMessage: message,\n    ...additionalData\n  };\n\n  await sessionRef.update\\({\n    podcasts: upsertPodcast\\(existingPodcasts, updatedPodcast\\),\n    updatedAt: FieldValue.serverTimestamp\\(\\)\n  }\\);\n}\n\ninterface PodcastSegment {\n  speaker: 'host1' | 'host2';\n  text: string;\n  emotion?: 'neutral' | 'excited' | 'curious' | 'amused';\n}\n\ninterface PodcastScript {\n  segments: PodcastSegment[];\n  estimatedDuration: number;\n}\n\ninterface PodcastGenerationRequest {\n  campaignId: string;\n  sessionId: string;\n  version: number;\n  story?: string;           // For script generation\n  sessionTitle?: string;    // For script generation\n  sessionDate?: string;     // Optional\n  script?: PodcastScript;   // Optional \\(backward compatibility\\)\n}\n\nexport const generatePodcastAudio = onCall\\(\n  {\n    cors: SHARED_CORS,\n    secrets: ['GOOGLE_AI_API_KEY', 'ELEVENLABS_API_KEY'],\n    timeoutSeconds: 900, // 15 minutes\n    memory: '1GiB'\n  },\n  async \\(request: CallableRequest<PodcastGenerationRequest>\\) => {\n    // Enable testing in emulator without auth\n    ensureAuthForTesting\\(request\\);\n\n    const { auth, data } = request;\n\n    if \\(!auth?.uid\\) {\n      throw new HttpsError\\('unauthenticated', 'User must be authenticated.'\\);\n    }\n\n    const { campaignId, sessionId, version, story, sessionTitle, sessionDate, script } = data;\n\n    // Standard validations\n    if \\(!campaignId || typeof campaignId !== 'string'\\) {\n      throw new HttpsError\\('invalid-argument', 'Missing campaignId.'\\);\n    }\n    if \\(!sessionId || typeof sessionId !== 'string'\\) {\n      throw new HttpsError\\('invalid-argument', 'Missing sessionId.'\\);\n    }\n    if \\(!version || typeof version !== 'number'\\) {\n      throw new HttpsError\\('invalid-argument', 'Missing version.'\\);\n    }\n\n    // If script not provided, story and sessionTitle required\n    if \\(!script\\) {\n      if \\(!story || typeof story !== 'string'\\) {\n        throw new HttpsError\\('invalid-argument', 'Missing story \\(required for script generation\\).'\\);\n      }\n      if \\(!sessionTitle || typeof sessionTitle !== 'string'\\) {\n        throw new HttpsError\\('invalid-argument', 'Missing sessionTitle \\(required for script generation\\).'\\);\n      }\n    } else {\n      if \\(!Array.isArray\\(script.segments\\) || script.segments.length === 0\\) {\n        throw new HttpsError\\('invalid-argument', 'Invalid script provided.'\\);\n      }\n    }\n\n    const googleAiKey = process.env.GOOGLE_AI_API_KEY;\n    const elevenlabsKey = process.env.ELEVENLABS_API_KEY;\n\n    if \\(!googleAiKey\\) {\n      throw new HttpsError\\('failed-precondition', 'Google AI API key not configured.'\\);\n    }\n    if \\(!elevenlabsKey\\) {\n      throw new HttpsError\\('failed-precondition', 'ElevenLabs API key not configured.'\\);\n    }\n\n    const db = getFirestore\\(\\);\n    const storage = getStorage\\(\\).bucket\\(\\);\n    const campaignRef = db.doc\\(`campaigns/${campaignId}`\\);\n    const campaignSnap = await campaignRef.get\\(\\);\n\n    if \\(!campaignSnap.exists\\) {\n      throw new HttpsError\\('not-found', 'Campaign not found.'\\);\n    }\n\n    const campaignData = campaignSnap.data\\(\\) || {};\n    if \\(!campaignData.members || !campaignData.members[auth.uid]\\) {\n      throw new HttpsError\\('permission-denied', 'User is not a campaign member.'\\);\n    }\n\n    const sessionRef = db.doc\\(`campaigns/${campaignId}/audioSessions/${sessionId}`\\);\n    const sessionSnap = await sessionRef.get\\(\\);\n\n    if \\(!sessionSnap.exists\\) {\n      throw new HttpsError\\('not-found', 'Session not found.'\\);\n    }\n\n    const sessionData = sessionSnap.data\\(\\) || {};\n    if \\(sessionData.ownerId !== auth.uid\\) {\n      throw new HttpsError\\('permission-denied', 'Only the session owner can generate podcasts.'\\);\n    }\n    const existingPodcasts = Array.isArray\\(sessionData.podcasts\\) ? sessionData.podcasts : [];\n    const existingEntry = existingPodcasts.find\\(\\(podcast: any\\) => podcast?.version === version\\);\n\n    const now = new Date\\(\\);\n    const initialPodcastEntry = {\n      version,\n      createdAt: existingEntry?.createdAt ?? now,\n      storyVersion: sessionData.storyRegenerationCount ?? existingEntry?.storyVersion ?? 1,\n      status: 'pending' as const,\n      progress: 0,\n      progressMessage: 'Starting podcast generation...'\n      // Remove scriptGeneratedAt, duration, script - set during generation\n    };\n\n    await sessionRef.update\\({\n      podcasts: upsertPodcast\\(existingPodcasts, initialPodcastEntry\\),\n      latestPodcastVersion: version,\n      updatedAt: FieldValue.serverTimestamp\\(\\)\n    }\\);\n\n    // RETURN IMMEDIATELY - Generation continues in background\n    // Frontend will listen to Firestore updates via onSnapshot\n\n    // Start generation asynchronously \\(don't await\\)\n    generatePodcastInBackground\\(\n      campaignId,\n      sessionId,\n      version,\n      script,        // May be undefined\n      story,         // May be undefined\n      sessionTitle,  // May be undefined\n      sessionDate,   // May be undefined\n      sessionRef,\n      existingPodcasts,\n      auth.uid,\n      storage\n    \\).catch\\(error => {\n      console.error\\('Background generation failed:', error\\);\n    }\\);\n\n    return {\n      success: true,\n      message: 'Podcast generation started'\n    };\n  }\n\\);\n\nfunction upsertPodcast\\(existing: any[], nextEntry: any\\): any[] {\n  const index = existing.findIndex\\(podcast => podcast?.version === nextEntry.version\\);\n  if \\(index === -1\\) {\n    return [...existing, nextEntry];\n  }\n  const updated = [...existing];\n  updated[index] = { ...existing[index], ...nextEntry };\n  return updated;\n}\n\nfunction parseScriptResponse\\(text: string\\): PodcastScript {\n  const segments: PodcastSegment[] = [];\n  const lines = text.split\\('\\\\n'\\).filter\\(line => line.trim\\(\\)\\);\n\n  for \\(const line of lines\\) {\n    const trimmedLine = line.trim\\(\\);\n    if \\(trimmedLine.startsWith\\('HOST1:'\\)\\) {\n      segments.push\\({\n        speaker: 'host1',\n        text: trimmedLine.replace\\('HOST1:', ''\\).trim\\(\\)\n      }\\);\n    } else if \\(trimmedLine.startsWith\\('HOST2:'\\)\\) {\n      segments.push\\({\n        speaker: 'host2',\n        text: trimmedLine.replace\\('HOST2:', ''\\).trim\\(\\)\n      }\\);\n    }\n  }\n\n  const totalWords = segments.reduce\\(\\(sum, seg\\) => sum + seg.text.split\\(/\\\\s+/\\).length, 0\\);\n  const estimatedDuration = Math.ceil\\(\\(totalWords / 150\\) * 60\\);\n\n  return { segments, estimatedDuration };\n}\n\n// Background generation function\nasync function generatePodcastInBackground\\(\n  campaignId: string,\n  sessionId: string,\n  version: number,\n  script: PodcastScript | undefined,\n  story: string | undefined,\n  sessionTitle: string | undefined,\n  sessionDate: string | undefined,\n  sessionRef: FirebaseFirestore.DocumentReference,\n  existingPodcasts: any[],\n  userId: string,\n  storage: any\n\\) {\n  const googleAiKey = process.env.GOOGLE_AI_API_KEY;\n  const elevenlabsKey = process.env.ELEVENLABS_API_KEY;\n\n  if \\(!googleAiKey || !elevenlabsKey\\) {\n    await updatePodcastProgress\\(sessionRef, existingPodcasts, version, 'failed', 0, 'API keys not configured', {\n      error: 'Required API keys are not configured'\n    }\\);\n    return;\n  }\n\n  const db = getFirestore\\(\\);\n  const googleAi = new GoogleGenAI\\({ apiKey: googleAiKey }\\);\n  const elevenlabs = new ElevenLabsClient\\({ apiKey: elevenlabsKey }\\);\n\n  const tempDir = fs.mkdtempSync\\(path.join\\(os.tmpdir\\(\\), 'podcast-'\\)\\);\n  const outputPath = path.join\\(tempDir, `podcast-${sessionId}-v${version}.mp3`\\);\n\n  try {\n    let finalScript: PodcastScript;\n    let modelUsed: string | undefined;\n    const settingsSnap = await db.doc\\('settings/ai'\\).get\\(\\);\n    const aiSettings = settingsSnap.data\\(\\) as AISettings | undefined;\n\n    if \\(!aiSettings\\) {\n      throw new Error\\('AI settings not configured in database'\\);\n    }\n\n    const hostVoices = resolveHostVoices\\(aiSettings\\);\n\n    // STEP 1: Generate script if not provided\n    if \\(!script\\) {\n      // Update unified session progress - script generation stage\n      await ProgressTrackerService.updateProgress\\(\n        campaignId,\n        sessionId,\n        'generating-podcast-script',\n        10,\n        'Generating podcast script...'\n      \\);\n\n      // 1.1 Load AI settings\n      await updatePodcastProgress\\(sessionRef, existingPodcasts, version, 'loading_context', 5, 'Loading AI settings...'\\);\n\n      const selectedModel = aiSettings.defaultModel;\n      const modelConfig = aiSettings.modelConfig?.[selectedModel];\n\n      if \\(!modelConfig\\) {\n        throw new Error\\(`Model configuration not found for: ${selectedModel}`\\);\n      }\n\n      modelUsed = selectedModel;\n\n      // 1.2 Generate script\n      await updatePodcastProgress\\(sessionRef, existingPodcasts, version, 'generating_script', 15,\n        `Generating script with ${selectedModel}...`\\);\n\n      const promptText = `${PODCAST_SCRIPT_GENERATOR_PROMPT}\\\\n\\\\nSESSION TITLE: ${sessionTitle}\\\\nSESSION DATE: ${\n        sessionDate || 'Unknown'\n      }\\\\n\\\\nSESSION STORY:\\\\n${story}\\\\n\\\\nGenereer een podcast script met natuurlijke dialoog tussen HOST1 \\(man\\) en HOST2 \\(vrouw\\).`;\n\n      const scriptResponse = await googleAi.models.generateContent\\({\n        model: selectedModel,\n        contents: [{ role: 'user', parts: [{ text: promptText }] }],\n        config: modelConfig\n      }\\);\n\n      if \\(!scriptResponse.text\\) {\n        throw new Error\\('No script generated by AI'\\);\n      }\n\n      // 1.3 Parse script\n      finalScript = parseScriptResponse\\(scriptResponse.text\\);\n\n      if \\(finalScript.segments.length === 0\\) {\n        throw new Error\\('Failed to parse script segments'\\);\n      }\n\n      // Validate character limit\n      const totalCharacters = finalScript.segments.reduce\\(\\(sum, seg\\) => sum + seg.text.length, 0\\);\n      logger.debug\\(`Generated script: ${totalCharacters} characters \\(limit: 5000\\)`\\);\n\n      if \\(totalCharacters > 5000\\) {\n        throw new Error\\(\n          `Script too long \\(${totalCharacters} chars\\). Maximum is 5000. Try a shorter story.`\n        \\);\n      }\n\n      await updatePodcastProgress\\(sessionRef, existingPodcasts, version, 'script_complete', 50,\n        `Script generated with ${finalScript.segments.length} segments`,\n        {\n          script: finalScript,\n          scriptGeneratedAt: new Date\\(\\),\n          duration: finalScript.estimatedDuration,\n          modelUsed: selectedModel\n        }\n      \\);\n\n      logger.debug\\(`Script: ${finalScript.segments.length} segments, ~${finalScript.estimatedDuration}s`\\);\n    } else {\n      // Script provided, skip generation\n      finalScript = script;\n      await updatePodcastProgress\\(sessionRef, existingPodcasts, version, 'script_complete', 50,\n        'Using provided script',\n        {\n          script: finalScript,\n          scriptGeneratedAt: new Date\\(\\),\n          duration: finalScript.estimatedDuration\n        }\n      \\);\n      logger.debug\\(`Using provided script: ${finalScript.segments.length} segments`\\);\n    }\n\n    // STEP 2: Generate audio \\(existing code continues\\)\n    // Update unified session progress - audio generation stage\n    await ProgressTrackerService.updateProgress\\(\n      campaignId,\n      sessionId,\n      'generating-podcast-audio',\n      55,\n      'Generating conversational podcast audio...'\n    \\);\n\n    await updatePodcastProgress\\(\n      sessionRef,\n      existingPodcasts,\n      version,\n      'generating_audio',\n      55,\n      'Generating conversational audio with text-to-dialogue...'\n    \\);\n\n    // 1. Format script for text-to-dialogue\n    // Convert segments to text-to-dialogue input format: array of { text, voiceId }\n    const dialogueInputs = finalScript.segments.map\\(seg => \\({\n      text: seg.text,\n      voiceId: hostVoices[seg.speaker as 'host1' | 'host2'] || hostVoices.host1\n    }\\)\\);\n\n    logger.debug\\(`Generating podcast with text-to-dialogue \\(${finalScript.segments.length} segments\\)`\\);\n\n    // 2. Call ElevenLabs text-to-dialogue API \\(SINGLE CALL\\)\n    await updatePodcastProgress\\(\n      sessionRef,\n      existingPodcasts,\n      version,\n      'generating_audio',\n      60,\n      'Calling ElevenLabs text-to-dialogue API...'\n    \\);\n\n    const audioStream = await elevenlabs.textToDialogue.convert\\({\n      inputs: dialogueInputs\n    }\\);\n\n    // Update: Receiving audio\n    await updatePodcastProgress\\(\n      sessionRef,\n      existingPodcasts,\n      version,\n      'generating_audio',\n      70,\n      'Receiving audio stream...'\n    \\);\n\n    // 3. Convert stream to buffer\n    const chunks: Buffer[] = [];\n    const readable = Readable.from\\(audioStream as any\\);\n\n    for await \\(const chunk of readable\\) {\n      chunks.push\\(Buffer.from\\(chunk\\)\\);\n    }\n\n    const audioBuffer = Buffer.concat\\(chunks\\);\n\n    if \\(audioBuffer.length === 0\\) {\n      throw new Error\\('Empty audio buffer from text-to-dialogue'\\);\n    }\n\n    logger.debug\\(`Generated podcast: ${audioBuffer.length} bytes`\\);\n    fs.writeFileSync\\(outputPath, audioBuffer\\);\n\n    // Update: Uploading to storage\n    await updatePodcastProgress\\(\n      sessionRef,\n      existingPodcasts,\n      version,\n      'uploading',\n      85,\n      'Uploading podcast to storage...'\n    \\);\n\n    // 4. Upload to Firebase Storage\n    const storagePath = `campaigns/${campaignId}/podcasts/${sessionId}/v${version}.mp3`;\n    const downloadToken = randomUUID\\(\\);\n\n    await storage.upload\\(outputPath, {\n      destination: storagePath,\n      metadata: {\n        contentType: 'audio/mpeg',\n        metadata: {\n          firebaseStorageDownloadTokens: downloadToken,\n          sessionId,\n          campaignId,\n          version: version.toString\\(\\),\n          userId\n        }\n      }\n    }\\);\n\n    const encodedPath = encodeURIComponent\\(storagePath\\);\n    const fileUrl = `https://firebasestorage.googleapis.com/v0/b/${storage.name}/o/${encodedPath}?alt=media&token=${downloadToken}`;\n    const fileSize = fs.statSync\\(outputPath\\).size;\n\n    // Update: Completed!\n    await updatePodcastProgress\\(\n      sessionRef,\n      existingPodcasts,\n      version,\n      'completed',\n      100,\n      'Podcast ready!',\n      {\n        audioUrl: fileUrl,\n        fileSize,\n        audioGeneratedAt: new Date\\(\\),\n        modelUsed: modelUsed,  // Add model info\n        error: null\n      }\n    \\);\n\n    // Update unified session progress - completed\n    await ProgressTrackerService.markCompleted\\(\n      campaignId,\n      sessionId,\n      'Podcast generation complete'\n    \\);\n\n    logger.debug\\(`Podcast generation completed: ${fileUrl}`\\);\n\n  } catch \\(error: any\\) {\n    console.error\\('Error generating podcast:', error\\);\n\n    await updatePodcastProgress\\(\n      sessionRef,\n      existingPodcasts,\n      version,\n      'failed',\n      0,\n      'Failed to generate podcast',\n      {\n        error: error?.message || 'Unknown error'\n      }\n    \\);\n\n    // Update unified session progress - failed\n    await ProgressTrackerService.markFailed\\(\n      campaignId,\n      sessionId,\n      'generating-podcast-audio',\n      error\n    \\);\n  } finally {\n    // Cleanup\n    safeUnlink\\(outputPath\\);\n    safeRemoveDir\\(tempDir\\);\n  }\n}\n\nfunction safeUnlink\\(filePath: string\\): void {\n  try {\n    if \\(fs.existsSync\\(filePath\\)\\) {\n      fs.unlinkSync\\(filePath\\);\n    }\n  } catch \\(error\\) {\n    logger.warn\\('Failed to delete temp file:', filePath, error\\);\n  }\n}\n\nfunction safeRemoveDir\\(dirPath: string\\): void {\n  try {\n    if \\(fs.existsSync\\(dirPath\\)\\) {\n      fs.rmSync\\(dirPath, { recursive: true, force: true }\\);\n    }\n  } catch \\(error\\) {\n    logger.warn\\('Failed to delete temp dir:', dirPath, error\\);\n  }\n}\n\nfunction resolveHostVoices\\(settings: AISettings\\): Record<'host1' | 'host2', string> {\n  const configured = settings.features?.podcastVoices;\n  const host1 = configured?.host1VoiceId?.trim\\(\\) || DEFAULT_HOST_VOICES.host1;\n  const host2 = configured?.host2VoiceId?.trim\\(\\) || DEFAULT_HOST_VOICES.host2;\n\n  if \\(!host1 || !host2\\) {\n    throw new Error\\(\n      'Podcast voice settings are missing. Configure them in Admin or set ELEVENLABS_HOST1_VOICE and ELEVENLABS_HOST2_VOICE.'\n    \\);\n  }\n\n  return { host1, host2 };\n}\nEOF)",
      "Bash(/tmp/worker-queue.service.ts << 'EOF'\nimport * as logger from '../utils/logger';\nimport {CallableRequest, onCall} from 'firebase-functions/v2/https';\n\n/**\n * Worker payload for chain communication\n */\nexport interface WorkerPayload {\n  sessionId: string;\n  [key: string]: unknown; // Additional data specific to each worker\n}\n\n/**\n * Type for worker handler function\n */\nexport type WorkerHandler = \\(data: WorkerPayload\\) => Promise<void>;\n\n/**\n * Service for managing worker chain communication\n * Uses direct function invocation pattern with fire-and-forget\n */\nexport class WorkerQueueService {\n  /**\n   * Trigger the next worker in the chain by calling it asynchronously\n   * This is a fire-and-forget pattern - we don't wait for the result\n   */\n  static async triggerWorker\\(\n    workerHandler: WorkerHandler,\n    payload: WorkerPayload\n  \\): Promise<void> {\n    // Trigger the next worker asynchronously \\(fire-and-forget\\)\n    // This allows the current worker to complete immediately\n    setImmediate\\(async \\(\\) => {\n      try {\n        await workerHandler\\(payload\\);\n      } catch \\(error\\) {\n        // Errors are logged but don't affect the caller\n        console.error\\(\n          `[WorkerQueue] Error triggering worker for session ${payload.sessionId}:`,\n          error\n        \\);\n      }\n    }\\);\n\n    logger.debug\\(\n      `[WorkerQueue] Triggered worker for session ${payload.sessionId}`\n    \\);\n  }\n\n  /**\n   * Create a worker function wrapper that handles the common pattern:\n   * 1. Return immediately\n   * 2. Process work asynchronously in background\n   */\n  static createWorker\\(workerName: string, handler: WorkerHandler\\) {\n    // Store the handler for internal use\n    const workerFunc = onCall\\(\n      {\n        timeoutSeconds: 1200, // 20 minutes default\n        memory: '2GiB',\n        secrets: ['GOOGLE_AI_API_KEY'], // Add secrets for all workers\n      },\n      async \\(\n        request: CallableRequest\n      \\): Promise<{success: boolean; stage: string}> => {\n        const data = request.data as WorkerPayload;\n        const {sessionId} = data;\n\n        logger.debug\\(`[${workerName}] Started for session ${sessionId}`\\);\n\n        try {\n          // Execute the worker logic asynchronously\n          // We return immediately but processing continues\n          setImmediate\\(async \\(\\) => {\n            try {\n              await handler\\(data\\);\n              logger.debug\\(`[${workerName}] Completed for session ${sessionId}`\\);\n            } catch \\(error\\) {\n              console.error\\(\n                `[${workerName}] Error for session ${sessionId}:`,\n                error\n              \\);\n            }\n          }\\);\n\n          // Return immediately \\(fire-and-forget pattern\\)\n          return {\n            success: true,\n            stage: workerName,\n          };\n        } catch \\(error\\) {\n          console.error\\(`[${workerName}] Immediate error:`, error\\);\n          throw error;\n        }\n      }\n    \\);\n\n    // Attach the handler to the function for internal calls\n    \\(workerFunc as any\\).__handler = handler;\n\n    return workerFunc;\n  }\n\n  /**\n   * Get the internal handler from a worker function\n   */\n  static getHandler\\(workerFunc: any\\): WorkerHandler {\n    return workerFunc.__handler;\n  }\n}\nEOF)",
      "Bash(/tmp/transcribe-audio-batch.ts << 'EOF'\nimport * as logger from './utils/logger';\nimport {GoogleGenAI} from '@google/genai';\nimport {CallableRequest, HttpsError, onCall} from 'firebase-functions/v2/https';\nimport {FieldValue, getFirestore} from 'firebase-admin/firestore';\nimport {storage} from 'firebase-admin';\nimport {\n  AIFeatureConfig,\n  AISettings,\n} from './types/audio-session.types';\nimport {ProgressTrackerService} from './services/progress-tracker.service';\nimport {BatchTranscriptionMetadata} from './services/transcription-batch.service';\nimport {buildTranscriptionPrompt} from './audio/transcription-prompt';\nimport {fetchKankaContextForTranscription} from './services/kanka.service';\n\n\nexport interface TranscribeAudioBatchRequest {\n  campaignId: string;\n  sessionId: string;\n  storageUrl: string;\n  audioFileName: string;\n  audioFileSize?: number;\n  userCorrections?: string;\n}\n\nexport const transcribeAudioBatch = onCall\\(\n  {\n    timeoutSeconds: 300,\n    memory: '1GiB',\n    secrets: ['GOOGLE_AI_API_KEY', 'GEMINI_CALLBACK_SECRET', 'KANKA_API_TOKEN'],\n  },\n  async \\(\n    request: CallableRequest<TranscribeAudioBatchRequest>\n  \\): Promise<{success: boolean; batchJobName: string; modelUsed: string}> => {\n    const {\n      campaignId,\n      sessionId,\n      storageUrl,\n      audioFileName,\n      userCorrections,\n    } = request.data;\n\n    if \\(!campaignId || !sessionId || !storageUrl || !audioFileName\\) {\n      throw new HttpsError\\(\n        'invalid-argument',\n        'Missing required fields: campaignId, sessionId, storageUrl, audioFileName'\n      \\);\n    }\n\n    if \\(!storageUrl.startsWith\\('gs://'\\)\\) {\n      throw new HttpsError\\(\n        'invalid-argument',\n        'storageUrl must be a gs:// URL'\n      \\);\n    }\n\n    const googleAiKey = process.env.GOOGLE_AI_API_KEY;\n    if \\(!googleAiKey\\) {\n      throw new HttpsError\\(\n        'failed-precondition',\n        'Google AI API key not configured'\n      \\);\n    }\n\n    const db = getFirestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n\n    // Fetch session document to get storage metadata\n    const sessionSnap = await sessionRef.get\\(\\);\n    if \\(!sessionSnap.exists\\) {\n      throw new HttpsError\\(\n        'not-found',\n        `Audio session ${sessionId} not found`\n      \\);\n    }\n\n    await ProgressTrackerService.updateProgress\\(\n      campaignId,\n      sessionId,\n      'batch-submitted',\n      30,\n      'Submitting transcription batch job...'\n    \\);\n\n    const settingsSnap = await db.doc\\('settings/ai'\\).get\\(\\);\n    const aiSettings = settingsSnap.data\\(\\) as AISettings | undefined;\n\n    if \\(!aiSettings\\) {\n      throw new HttpsError\\(\n        'failed-precondition',\n        'AI settings not configured in database'\n      \\);\n    }\n\n    const transcriptionConfig: AIFeatureConfig = aiSettings.features\n      ?.transcription ?? {\n      model: aiSettings.defaultModel,\n      temperature: 0.1,\n      topP: 1,\n      topK: 40,\n      maxOutputTokens: 32000,\n    };\n\n    const model = resolveModel\\(aiSettings, transcriptionConfig.model\\);\n    const mimeType = resolveMimeType\\(\n      sessionSnap.data\\(\\)?.storageMetadata?.contentType,\n      audioFileName\n    \\);\n\n    const googleAi = new GoogleGenAI\\({apiKey: googleAiKey}\\);\n    const callbackUri = buildCallbackUri\\(\\);\n\n    if \\(!callbackUri\\) {\n      logger.warn\\(\n        '[transcribeAudioBatch] Callback URL not configured; polling fallback only.'\n      \\);\n    }\n\n    // Generate signed URL for Gemini API access\n    // Batch jobs can take up to 48 hours, so make URL valid for 48 hours\n    const bucket = storage\\(\\).bucket\\(\\);\n    const filePath = storageUrl.replace\\(`gs://${bucket.name}/`, ''\\);\n    const file = bucket.file\\(filePath\\);\n\n    logger.debug\\(`[transcribeAudioBatch] Generating signed URL for: ${filePath}`\\);\n\n    const [signedUrl] = await file.getSignedUrl\\({\n      action: 'read',\n      expires: Date.now\\(\\) + 48 * 60 * 60 * 1000, // 48 hours\n    }\\);\n\n    logger.debug\\(`[transcribeAudioBatch] Signed URL generated, valid for 48 hours`\\);\n\n    // Fetch Kanka enabled setting from campaign settings\n    const kankaEnabled = await getCampaignKankaEnabled\\(campaignId\\);\n\n    // Fetch Kanka context if enabled\n    const kankaContext = await fetchKankaContextForTranscription\\(\n      campaignId,\n      sessionId,\n      kankaEnabled\n    \\);\n\n    // Create inline batch request\n    // Using inline requests to avoid Gemini API bug with file-based output names\n    // Using signed URL to bypass Firebase Storage auth requirements\n    const inlineRequest = {\n      contents: [\n        {\n          parts: [\n            {text: buildTranscriptionPrompt\\(kankaContext\\)},\n            {\n              fileData: {\n                mimeType: mimeType,\n                fileUri: signedUrl,\n              },\n            },\n          ],\n        },\n      ],\n      generationConfig: {\n        temperature: transcriptionConfig.temperature,\n        topK: transcriptionConfig.topK,\n        topP: transcriptionConfig.topP,\n        maxOutputTokens: transcriptionConfig.maxOutputTokens,\n      },\n    };\n\n    // Save request to Cloud Storage for reference\n    const inputFilePath = `batch-requests/${sessionId}-input.json`;\n    const inputFile = bucket.file\\(inputFilePath\\);\n    await inputFile.save\\(JSON.stringify\\(inlineRequest, null, 2\\), {\n      contentType: 'application/json',\n      metadata: {\n        campaignId,\n        sessionId,\n      },\n    }\\);\n\n    const inputGcsUri = `gs://${bucket.name}/${inputFilePath}`;\n\n    console.dir\\(inlineRequest, {depth: 9}\\);\n\n    // Create batch job with inline requests\n    // Responses will be returned directly in the batch job, avoiding file access issues\n    const batchJob = await googleAi.batches.create\\({\n      model,\n      src: [inlineRequest],\n      config: {\n        displayName: `transcription-${sessionId}`,\n      },\n    }\\);\n\n    const batchJobName =\n      typeof batchJob.name === 'string' ? batchJob.name : '';\n    if \\(!batchJobName\\) {\n      throw new HttpsError\\(\n        'internal',\n        'Batch job created without a job name'\n      \\);\n    }\n\n    const batchMetadata: BatchTranscriptionMetadata = {\n      batchJobName,\n      modelUsed: model,\n      generationConfig: {\n        temperature: transcriptionConfig.temperature,\n        topK: transcriptionConfig.topK,\n        topP: transcriptionConfig.topP,\n        maxOutputTokens: transcriptionConfig.maxOutputTokens,\n      },\n      storageUrl,\n      audioFileName,\n      mimeType,\n      enableKankaContext: kankaEnabled,\n      userCorrections,\n      inputGcsUri,\n      submittedAt: FieldValue.serverTimestamp\\(\\),\n      status: 'submitted',\n    };\n\n    await sessionRef.update\\({\n      transcriptionBatch: batchMetadata,\n      'modelsUsed.transcription': model,\n    }\\);\n\n    await ProgressTrackerService.updateProgress\\(\n      campaignId,\n      sessionId,\n      'batch-submitted',\n      40,\n      'Batch job submitted. Waiting for transcription to complete...'\n    \\);\n\n    return {\n      success: true,\n      batchJobName,\n      modelUsed: model,\n    };\n  }\n\\);\n\n/**\n * Helper function to fetch Kanka enabled setting from campaign settings\n */\nasync function getCampaignKankaEnabled\\(campaignId: string\\): Promise<boolean> {\n  const db = getFirestore\\(\\);\n  const campaignRef = db.collection\\('campaigns'\\).doc\\(campaignId\\);\n  const campaignSnap = await campaignRef.get\\(\\);\n\n  if \\(!campaignSnap.exists\\) {\n    logger.warn\\(`Campaign ${campaignId} not found, defaulting kankaEnabled to false`\\);\n    return false;\n  }\n\n  const campaignData = campaignSnap.data\\(\\);\n  return campaignData?.settings?.kankaEnabled ?? false;\n}\n\nfunction resolveModel\\(settings: AISettings, requestedModel?: string\\): string {\n  const availableModels = settings.availableModels ?? [];\n  const fallback = settings.defaultModel || 'gemini-2.5-flash';\n  if \\(requestedModel && availableModels.length > 0\\) {\n    return availableModels.includes\\(requestedModel\\) ? requestedModel : fallback;\n  }\n  return requestedModel || fallback;\n}\n\nfunction resolveMimeType\\(\n  sessionContentType: string | undefined,\n  audioFileName: string\n\\): string {\n  if \\(sessionContentType\\) {\n    return sessionContentType;\n  }\n\n  const extension = audioFileName.split\\('.'\\).pop\\(\\)?.toLowerCase\\(\\);\n  switch \\(extension\\) {\n    case 'wav':\n      return 'audio/wav';\n    case 'mp3':\n      return 'audio/mpeg';\n    case 'm4a':\n      return 'audio/mp4';\n    case 'webm':\n      return 'audio/webm';\n    case 'ogg':\n      return 'audio/ogg';\n    case 'flac':\n      return 'audio/flac';\n    default:\n      return 'audio/mpeg';\n  }\n}\n\nfunction buildCallbackUri\\(\\): string | null {\n  return 'https://geminicallback-oeoug4az2a-ew.a.run.app';\n}\nEOF)",
      "Bash(/tmp/progress-tracker.service.ts << 'EOF'\nimport * as logger from '../utils/logger';\nimport {firestore} from 'firebase-admin';\nimport {Timestamp} from 'firebase-admin/firestore';\nimport {SessionProgress, SessionProgressStage} from '../types/audio-session.types';\n\n/**\n * @deprecated Use SessionProgress from audio-session.types instead\n */\nexport type ProgressStage =\n  | 'uploading'\n  | 'submitted'\n  | 'downloading'\n  | 'chunking'\n  | 'transcribing'\n  | 'generating-story'\n  | 'completed'\n  | 'failed';\n\n/**\n * @deprecated Use SessionProgress from audio-session.types instead\n */\nexport interface ProgressFailure {\n  stage: string;\n  error: string;\n  timestamp: Timestamp;\n  details?: unknown;\n}\n\n/**\n * @deprecated Use SessionProgress from audio-session.types instead\n */\nexport interface AudioSessionProgress {\n  stage: ProgressStage;\n  progress: number; // 0-100 percentage\n  currentStep?: string; // Optional detailed step description\n  failure?: ProgressFailure;\n  updatedAt: Timestamp;\n}\n\n/**\n * Service for tracking progress of audio session processing \\(Ticket #43\\)\n */\nexport class ProgressTrackerService {\n  /**\n   * Update progress for an audio session using new unified SessionProgress\n   */\n  static async updateProgress\\(\n    campaignId: string,\n    sessionId: string,\n    stage: SessionProgressStage,\n    progress: number,\n    message: string,\n    estimatedCompletionAt?: Date\n  \\): Promise<void> {\n    const db = firestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n\n    // Get existing progress to preserve startedAt if stage hasn't changed\n    const sessionDoc = await sessionRef.get\\(\\);\n    const existingProgress = sessionDoc.data\\(\\)?.progress as SessionProgress | undefined;\n    const stageChanged = !existingProgress || existingProgress.stage !== stage;\n\n    const now = new Date\\(\\);\n    const progressData: SessionProgress = {\n      stage,\n      progress: Math.min\\(100, Math.max\\(0, progress\\)\\), // Clamp between 0-100\n      message,\n      startedAt: stageChanged ? now : \\(existingProgress?.startedAt || now\\),\n      updatedAt: now,\n    };\n\n    if \\(estimatedCompletionAt\\) {\n      progressData.estimatedCompletionAt = estimatedCompletionAt;\n    }\n\n    await sessionRef.update\\({\n      progress: progressData,\n    }\\);\n\n    logger.debug\\(\n      `[Progress] Session ${sessionId}: ${stage} \\(${progress}%\\) - ${message}`\n    \\);\n  }\n\n  /**\n   * Mark session as failed with error details\n   */\n  static async markFailed\\(\n    campaignId: string,\n    sessionId: string,\n    stage: SessionProgressStage,\n    error: Error | string,\n    details?: unknown\n  \\): Promise<void> {\n    const db = firestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n\n    const errorMessage = error instanceof Error ? error.message : error;\n    const errorDetails = details || \\(error instanceof Error ? error.stack : undefined\\);\n\n    const now = new Date\\(\\);\n    const progressData: SessionProgress = {\n      stage: 'failed',\n      progress: 0,\n      message: `Failed: ${errorMessage}`,\n      startedAt: now,\n      error: errorMessage + \\(errorDetails ? `\\\\n\\\\nDetails: ${JSON.stringify\\(errorDetails, null, 2\\)}` : ''\\),\n      updatedAt: now,\n    };\n\n    await sessionRef.update\\({\n      progress: progressData,\n    }\\);\n\n    console.error\\(\n      `[Progress] Session ${sessionId} FAILED at ${stage}:`,\n      errorMessage,\n      details\n    \\);\n  }\n\n  /**\n   * Mark session as completed\n   */\n  static async markCompleted\\(\n    campaignId: string,\n    sessionId: string,\n    message = 'Processing complete'\n  \\): Promise<void> {\n    await this.updateProgress\\(\n      campaignId,\n      sessionId,\n      'completed',\n      100,\n      message\n    \\);\n  }\n\n  /**\n   * Clear progress \\(set to idle\\)\n   */\n  static async clearProgress\\(\n    campaignId: string,\n    sessionId: string\n  \\): Promise<void> {\n    const db = firestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n\n    await sessionRef.update\\({\n      progress: firestore.FieldValue.delete\\(\\),\n    }\\);\n\n    logger.debug\\(`[Progress] Session ${sessionId}: Progress cleared`\\);\n  }\n\n  /**\n   * Get current progress for a session\n   */\n  static async getProgress\\(\n    campaignId: string,\n    sessionId: string\n  \\): Promise<SessionProgress | null> {\n    const db = firestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n    const doc = await sessionRef.get\\(\\);\n\n    if \\(!doc.exists\\) {\n      return null;\n    }\n\n    const data = doc.data\\(\\);\n    return data?.progress || null;\n  }\n}\nEOF)",
      "Bash(/tmp/story-generation-worker.ts << 'EOF'\nimport * as logger from '../utils/logger';\nimport {HttpsError} from 'firebase-functions/v2/https';\nimport {getFirestore} from 'firebase-admin/firestore';\nimport {ProgressTrackerService} from '../services/progress-tracker.service';\nimport {WorkerQueueService, WorkerPayload} from '../services/worker-queue.service';\nimport {generateStoryFromTranscription} from '../story/story-generator.service';\nimport {\n  AISettings,\n  KankaSearchResult,\n} from '../types/audio-session.types';\n\nexport interface StoryGenerationWorkerPayload extends WorkerPayload {\n  campaignId: string;\n  sessionId: string;\n  transcriptionText: string;\n  enableKankaContext?: boolean;\n  userCorrections?: string;\n}\n\n/**\n * Story Generation Worker Handler: The actual processing logic\n */\nexport const storyGenerationWorkerHandler = async \\(data: WorkerPayload\\) => {\n    const {\n      campaignId,\n      sessionId,\n      transcriptionText,\n      enableKankaContext,\n      userCorrections,\n    } = data as StoryGenerationWorkerPayload;\n\n    if \\(!campaignId || !sessionId || !transcriptionText\\) {\n      throw new HttpsError\\(\n        'invalid-argument',\n        'Missing required fields: campaignId, sessionId, transcriptionText'\n      \\);\n    }\n\n    const googleAiKey = process.env.GOOGLE_AI_API_KEY;\n    if \\(!googleAiKey\\) {\n      throw new HttpsError\\(\n        'failed-precondition',\n        'Google AI API key not configured'\n      \\);\n    }\n\n    const db = getFirestore\\(\\);\n    const sessionRef = db\n      .collection\\('campaigns'\\)\n      .doc\\(campaignId\\)\n      .collection\\('audioSessions'\\)\n      .doc\\(sessionId\\);\n\n    try {\n      // Update progress: Starting story generation \\(80%\\)\n      await ProgressTrackerService.updateProgress\\(\n        campaignId,\n        sessionId,\n        'generating-story',\n        80,\n        'Loading AI settings for story generation...'\n      \\);\n\n      // Load AI settings\n      const settingsSnap = await db.doc\\('settings/ai'\\).get\\(\\);\n      const aiSettings = settingsSnap.data\\(\\) as AISettings | undefined;\n\n      if \\(!aiSettings\\) {\n        throw new Error\\('AI settings not configured in database'\\);\n      }\n\n      const storyConfig = aiSettings.features?.storyGeneration || {\n        model: aiSettings.defaultModel,\n        temperature: 0.8,\n        topP: 0.95,\n        topK: 40,\n        maxOutputTokens: 32000,\n      };\n\n      // Load Kanka context if enabled\n      let kankaContext: KankaSearchResult | undefined;\n      if \\(enableKankaContext\\) {\n        const sessionSnap = await sessionRef.get\\(\\);\n        const sessionData = sessionSnap.data\\(\\);\n        kankaContext = sessionData?.kankaSearchResult as\n          | KankaSearchResult\n          | undefined;\n      }\n\n      // Update progress: Generating story \\(85%\\)\n      await ProgressTrackerService.updateProgress\\(\n        campaignId,\n        sessionId,\n        'generating-story',\n        85,\n        'Generating story from transcription...'\n      \\);\n\n      logger.debug\\(`[StoryGenerationWorker] Generating story for ${sessionId}...`\\);\n\n      // Generate story\n      const storyContent = await generateStoryFromTranscription\\(\n        transcriptionText,\n        storyConfig,\n        kankaContext,\n        userCorrections\n      \\);\n\n      logger.debug\\(\n        `[StoryGenerationWorker] Story generated: ${storyContent.length} characters`\n      \\);\n\n      // Save story to Firestore\n      await sessionRef.update\\({\n        content: storyContent,\n        storyGeneratedAt: new Date\\(\\).toISOString\\(\\),\n        status: 'completed',\n      }\\);\n\n      // Mark session as completed \\(100%\\)\n      await ProgressTrackerService.markCompleted\\(campaignId, sessionId\\);\n\n      logger.debug\\(\n        `[StoryGenerationWorker] Completed processing for session ${sessionId}`\n      \\);\n    } catch \\(error\\) {\n      console.error\\(\n        `[StoryGenerationWorker] Error for session ${sessionId}:`,\n        error\n      \\);\n      await ProgressTrackerService.markFailed\\(\n        campaignId,\n        sessionId,\n        'generating-story',\n        error as Error\n      \\);\n      throw error;\n    }\n};\n\n/**\n * Story Generation Worker: Cloud Function wrapper\n *\n * This is the final worker in the transcription chain.\n * Chain: submit â†’ transcribe â†’ generate story â†’ completed\n */\nexport const storyGenerationWorker = WorkerQueueService.createWorker\\(\n  'storyGenerationWorker',\n  storyGenerationWorkerHandler\n\\);\nEOF)",
      "Bash(/tmp/fix_warn.js << 'EOF'\nconst fs = require\\('fs'\\);\nconst path = require\\('path'\\);\n\nconst file = '/Users/mattcady/git/questmind/functions/src/generate-podcast-audio.ts';\nlet content = fs.readFileSync\\(file, 'utf-8'\\);\n\n// Fix the logger.warn calls to combine multiple arguments\ncontent = content.replace\\(\n  \"logger.warn\\('Failed to delete temp file:', filePath, error\\);\",\n  \"logger.warn\\(`Failed to delete temp file: ${filePath}`, error\\);\"\n\\);\n\ncontent = content.replace\\(\n  \"logger.warn\\('Failed to delete temp dir:', dirPath, error\\);\",\n  \"logger.warn\\(`Failed to delete temp dir: ${dirPath}`, error\\);\"\n\\);\n\nfs.writeFileSync\\(file, content, 'utf-8'\\);\nconsole.log\\('Fixed logger.warn calls in generate-podcast-audio.ts'\\);\nEOF)",
      "Bash(__NEW_LINE_e7934f3964505f88__ node /tmp/fix_warn.js)",
      "Bash(/tmp/summary.txt << 'EOF'\nLOGGER UTILITY MIGRATION - SUMMARY\n==================================\n\nSuccessfully replaced all console.log\\(\\), console.info\\(\\), and console.warn\\(\\) calls \nwith the logger utility in all specified backend TypeScript files.\n\nFILES UPDATED \\(11 total\\):\n========================\n\n1. /Users/mattcady/git/questmind/functions/src/transcribe-audio-fast.ts\n   - Added: import * as logger from './utils/logger';\n   - Replaced 5 console.log\\(\\) calls with logger.debug\\(\\)\n   - Replaced 1 console.warn\\(\\) call with logger.warn\\(\\)\n   - Kept 3 console.error\\(\\) calls unchanged\n\n2. /Users/mattcady/git/questmind/functions/src/utils/check-batch-status.ts\n   - Added: import * as logger from './logger';\n   - Replaced 4 console.log\\(\\) calls with logger.info\\(\\)\n\n3. /Users/mattcady/git/questmind/functions/src/generate-podcast-audio.ts\n   - Added: import * as logger from './utils/logger';\n   - Replaced 4 console.log\\(\\) calls with logger.debug\\(\\)\n   - Replaced 2 console.warn\\(\\) calls with logger.warn\\(\\) \\(combined args\\)\n   - Kept 2 console.error\\(\\) calls unchanged\n\n4. /Users/mattcady/git/questmind/functions/src/services/kanka.service.ts\n   - Added: import * as logger from '../utils/logger';\n   - Replaced 1 console.warn\\(\\) call with logger.warn\\(\\)\n   - Replaced 1 console.log\\(\\) call with logger.debug\\(\\)\n   - Kept 4 console.error\\(\\) calls unchanged\n\n5. /Users/mattcady/git/questmind/functions/src/services/worker-queue.service.ts\n   - Added: import * as logger from '../utils/logger';\n   - Replaced 2 console.log\\(\\) calls with logger.debug\\(\\)\n   - Kept 3 console.error\\(\\) calls unchanged\n\n6. /Users/mattcady/git/questmind/functions/src/transcribe-audio-batch.ts\n   - Added: import * as logger from './utils/logger';\n   - Replaced 1 console.warn\\(\\) call with logger.warn\\(\\)\n   - Replaced 2 console.log\\(\\) calls with logger.debug\\(\\)\n   - Kept 0 console.error\\(\\) calls\n\n7. /Users/mattcady/git/questmind/functions/src/services/progress-tracker.service.ts\n   - Added: import * as logger from '../utils/logger';\n   - Replaced 1 console.log\\(\\) call with logger.debug\\(\\)\n   - Kept 1 console.error\\(\\) call unchanged\n\n8. /Users/mattcady/git/questmind/functions/src/workers/story-generation-worker.ts\n   - Added: import * as logger from '../utils/logger';\n   - Replaced 2 console.log\\(\\) calls with logger.debug\\(\\)\n   - Kept 1 console.error\\(\\) call unchanged\n\n9. /Users/mattcady/git/questmind/functions/src/poll-batch-jobs.ts\n   - Added: import * as logger from './utils/logger';\n   - Replaced 1 console.log\\(\\) call with logger.debug\\(\\)\n   - Replaced 1 console.warn\\(\\) call with logger.warn\\(\\)\n   - Kept 2 console.error\\(\\) calls unchanged\n\n10. /Users/mattcady/git/questmind/functions/src/utils/emulator-helpers.ts\n    - Added: import * as logger from './logger';\n    - Replaced 1 console.warn\\(\\) call with logger.warn\\(\\)\n\n11. /Users/mattcady/git/questmind/functions/src/story/story-generator.service.ts\n    - Added: import * as logger from '../utils/logger';\n    - Replaced 2 console.log\\(\\) calls with logger.debug\\(\\)\n\nIMPORT PATHS USED:\n=================\n- functions/src/*.ts â†’ './utils/logger'\n- functions/src/services/*.ts â†’ '../utils/logger'\n- functions/src/workers/*.ts â†’ '../utils/logger'\n- functions/src/utils/*.ts â†’ './logger'\n- functions/src/story/*.ts â†’ '../utils/logger'\n\nREPLACEMENTS MADE:\n=================\n- console.log\\(\\) â†’ logger.debug\\(\\)\n- console.info\\(\\) â†’ logger.info\\(\\)\n- console.warn\\(\\) â†’ logger.warn\\(\\)\n- console.error\\(\\) â†’ KEPT UNCHANGED \\(per instructions\\)\n\nBUILD STATUS:\n=============\nâœ“ Backend build \\(npm run build:backend\\) - PASSED\nâœ“ Frontend build \\(npm run build\\) - PASSED\n\nAll files compile without errors.\nEOF)",
      "Bash(/Users/mattcady/git/questmind/src/app/shared/logger.ts << 'EOF'\nimport { environment } from '../../environments/environment';\n\nconst isProduction = environment.production;\n\nexport function warn\\(message: string, context?: any\\): void {\n  if \\(context !== undefined\\) {\n    console.warn\\(`[WARN] ${message}`, context\\);\n  } else {\n    console.warn\\(`[WARN] ${message}`\\);\n  }\n}\n\nexport function info\\(message: string, context?: any\\): void {\n  if \\(isProduction\\) return;\n\n  if \\(context !== undefined\\) {\n    console.info\\(`[INFO] ${message}`, context\\);\n  } else {\n    console.info\\(`[INFO] ${message}`\\);\n  }\n}\n\nexport function debug\\(message: string, context?: any\\): void {\n  if \\(isProduction\\) return;\n\n  if \\(context !== undefined\\) {\n    console.log\\(`[DEBUG] ${message}`, context\\);\n  } else {\n    console.log\\(`[DEBUG] ${message}`\\);\n  }\n}\n\nexport function error\\(message: string, context?: any\\): void {\n  if \\(context !== undefined\\) {\n    console.error\\(`[ERROR] ${message}`, context\\);\n  } else {\n    console.error\\(`[ERROR] ${message}`\\);\n  }\n}\nEOF)",
      "Bash(/tmp/fix.ts << 'EOF'\n    if \\(session.progress\\) {\n      return session.progress;\n    }\n\n    // Otherwise, create synthetic progress from legacy status field\n    if \\(session.status === 'failed'\\) {\n      return {\n        stage: 'failed' as const,\n        progress: 0,\n        message: 'Transcription failed. Click retry to try again.',\n        error: undefined,\n        startedAt: new Date\\(session.createdAt\\),\n        updatedAt: new Date\\(session.updatedAt || session.createdAt\\)\n      };\n    }\nEOF)",
      "Bash(python3:*)",
      "Bash(/tmp/update_models.ts << 'EOF'\n// Add these exports at the end of audio-session.models.ts\n\nexport type { UploadProgress, UnifiedProgress } from '../core/models/schemas/audio-session.schema';\nEOF)",
      "Bash(echo:*)",
      "mcp__angular-cli__search_documentation",
      "WebFetch(domain:angular.dev)",
      "WebFetch(domain:developer.chrome.com)",
      "WebFetch(domain:chromestatus.com)",
      "Bash(/Users/mattcady/git/questmind/cors.json << 'CORSEOF'\n[\n  {\n    \"origin\": [\"https://questmind.nl\", \"http://localhost:4200\"],\n    \"method\": [\"PUT\", \"OPTIONS\"],\n    \"responseHeader\": [\"Content-Type\"],\n    \"maxAgeSeconds\": 3600\n  }\n]\nCORSEOF)",
      "mcp__context7__resolve-library-id",
      "mcp__context7__query-docs",
      "Bash(npm run lint:*)",
      "Bash(firebase functions:log:*)",
      "Bash(gcloud run services get-iam-policy:*)",
      "Bash(gcloud run services add-iam-policy-binding:*)",
      "mcp__angular-cli__find_examples"
    ]
  },
  "enableAllProjectMcpServers": true,
  "enabledMcpjsonServers": [
    "firebase"
  ],
  "outputStyle": "default"
}
