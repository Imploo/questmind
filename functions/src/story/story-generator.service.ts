import * as logger from '../utils/logger';
import { GoogleGenAI } from '@google/genai';
import { AIFeatureConfig, KankaSearchResult, PreviousStory } from '../types/audio-session.types';
import { SESSION_STORY_GENERATOR_PROMPT } from '../prompts/session-story-generator.prompt';

/**
 * Generates a polished story from a raw story narrative
 *
 * @param rawStory - Raw story narrative from transcription
 * @param config - AI model configuration
 * @param kankaContext - Optional campaign context for accuracy
 * @param userCorrections - Optional DM corrections to apply
 * @param previousStories - Optional previous session stories for flashbacks/memories
 * @returns Generated story content
 */
export async function generateStoryFromTranscription(
  rawStory: string,
  config: AIFeatureConfig,
  kankaContext?: KankaSearchResult,
  userCorrections?: string,
  previousStories?: PreviousStory[]
): Promise<string> {
  const googleAiKey = process.env.GOOGLE_AI_API_KEY;
  if (!googleAiKey) {
    throw new Error('Google AI API key not configured');
  }

  const googleAi = new GoogleGenAI({ apiKey: googleAiKey });

  logger.debug(`Generating story with ${config.model}...`);

  const storyPrompt = buildStoryPrompt(rawStory, kankaContext, userCorrections, previousStories);

  const storyResponse = await googleAi.models.generateContent({
    model: config.model,
    contents: [{ role: 'user', parts: [{ text: storyPrompt }] }],
    config: {
      temperature: config.temperature,
      topP: config.topP,
      topK: config.topK,
      maxOutputTokens: config.maxOutputTokens
    }
  });

  if (!storyResponse.text) {
    throw new Error('No story generated by AI');
  }

  const storyContent = storyResponse.text.trim();

  logger.debug(`Story generated: ${storyContent.length} characters`);

  return storyContent;
}

/**
 * Builds story generation prompt with context and corrections
 */
function buildStoryPrompt(
  rawStory: string,
  kankaContext?: KankaSearchResult,
  userCorrections?: string,
  previousStories?: PreviousStory[]
): string {
  let prompt = SESSION_STORY_GENERATOR_PROMPT;

  if (kankaContext && Object.keys(kankaContext).length > 0) {
    const contextPrompt = buildKankaContextPrompt(kankaContext);
    prompt += `\n\n${contextPrompt}`;
  }

  if (previousStories && previousStories.length > 0) {
    const storySummaries = previousStories
      .map(s => `### ${s.title} (${s.sessionDate})\n${s.content}`)
      .join('\n\n---\n\n');

    prompt += `\n\nPREVIOUS SESSION STORIES (for reference and flashbacks):
The following are recaps of earlier sessions in chronological order.
You may subtly reference these events as flashbacks, memories, or callbacks when relevant to the current session.

${storySummaries}`;
  }

  if (userCorrections && userCorrections.trim().length > 0) {
    prompt += `\n\nDM CORRECTIONS:\n${userCorrections}`;
  }

  prompt += `\n\nRAW SESSION STORY:\n${rawStory}`;

  return prompt;
}

/**
 * Formats Kanka context for prompt injection
 */
function buildKankaContextPrompt(context: KankaSearchResult): string {
  const sections: string[] = [];

  const addSection = (
    label: string,
    entities: { name: string; entry?: string; entry_parsed?: string }[] | undefined
  ) => {
    if (!entities?.length) {
      return;
    }
    const names = entities.map(entity => entity.name).join(', ');
    sections.push(`${label}: ${names}`);
  };

  addSection('Characters', context.characters);
  addSection('Locations', context.locations);
  addSection('Quests', context.quests);
  addSection('Organisations', context.organisations);

  if (context.journals?.length) {
    const journalEntries = context.journals
      .filter(j => j.name && j.entry_parsed)
      .map(j => {
        const date = j.date ? ` (${j.date})` : '';
        return `- ${j.name}${date}: ${j.entry_parsed}`;
      })
      .join('\n');
    if (journalEntries) {
      sections.push(`Journals:\n${journalEntries}`);
    }
  }

  if (sections.length === 0) {
    return '';
  }

  return `CAMPAIGN REFERENCE (for name/place accuracy only):
${sections.join('\n')}

Remember: Use this context ONLY to spell names and places correctly when you hear them. Do not add information that wasn't spoken.`;
}
