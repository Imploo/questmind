rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    function isCampaignMember(campaignId) {
      return request.auth != null && (
        // Check if campaign ID is in user's profile (matches Firestore rules primary check)
        (firestore.exists(/databases/(default)/documents/users/$(request.auth.uid)) &&
          campaignId in firestore.get(/databases/(default)/documents/users/$(request.auth.uid)).data.campaigns) ||
        // Fallback: check campaign document members directly
        (firestore.exists(/databases/(default)/documents/campaigns/$(campaignId)) &&
          request.auth.uid in firestore.get(/databases/(default)/documents/campaigns/$(campaignId)).data.members)
      );
    }

    // Audio files (campaigns)
    // Write only requires authentication — session IDs are UUIDs (unguessable) and the
    // backend validates campaign membership before processing. Cross-service Firestore
    // reads in Storage rules are unreliable for write-gating.
    match /campaigns/{campaignId}/audio/{sessionId}/{filename} {
      allow read: if isCampaignMember(campaignId);
      allow write: if request.auth != null
                   && request.resource.size < 500 * 1024 * 1024
                   && request.resource.contentType.matches('audio/.*');
    }

    // Podcast files (campaigns)
    match /campaigns/{campaignId}/podcasts/{sessionId}/{filename} {
      allow read: if isCampaignMember(campaignId);
      allow write: if isCampaignMember(campaignId)
                   && request.resource.size < 100 * 1024 * 1024
                   && (request.resource.contentType == 'audio/mpeg'
                       || request.resource.contentType == 'audio/mp3'
                       || request.resource.contentType == 'audio/m4a');
    }

    // Generated character images — owner can delete, anyone can read via download token
    match /images/{characterId}/{filename} {
      allow read: if true;
      allow delete: if request.auth != null &&
        firestore.get(/databases/(default)/documents/characters/$(characterId)).data.userId == request.auth.uid;
      // Write handled by backend only
    }

    // Chat images per character
    match /chat/{characterId}/{filename} {
      allow read: if request.auth != null;
      // Write handled by backend only
    }

    // Chat images (fallback for characters without ID)
    match /chat-images/{filename} {
      allow read: if request.auth != null;
      // Write handled by backend only
    }
  }
}
